
	ORG	&8000


MIKE1	EQU	&80

*********************************************
*	DISK LOADER	*
*********************************************
DISKZP	EQU	$F0
DSTATUS	EQU	DISKZP	;disk status fori/o
BUFFSB	EQU	DISKZP+1	;buffer for serial Weetabix
COUNTDOWN	EQU	DISKZP+2	;count
TEMP1D	EQU	DISKZP+3	;temp
TEMP2	EQU	DISKZP+4	
C3PO	EQU	DISKZP+5	;flag serial buffer out
ENDPRG	EQU	DISKZP+6	;word address end address
FD	EQU	DISKZP+8	
COMMAND	EQU	DISKZP+10

	; LOAD use size of file on disk.
	; interrupts must be disable for load and save
	; DISKADDRESS   = Start Address
	; DISKADDRESS+2 = Length of Data (Save Only)
	; FILENAME      = Length of filename
	; FILENAME+1    = Filename (ASC)

DISK_LOAD	LDA	FILESTL,Y	; Y what block to load in
	STA	MIKE1
	LDA	FILESTH,Y
	STA	MIKE1+1
	LDY	#255	; load single file in
	STY	FILELOOP+1
NEXTFILE	LDY	#12
HL	LDA	#0
	STA	DISKZP,Y
	DEY
	BPL	HL
	LDX	#0
EF	NOP
	NOP
	DEX
	BNE	EF	; X =0 for file length and ptr
FILELOOP	LDY	#0	; load next file
GETNAME	INY
	LDA	(MIKE1),Y
	BEQ	SETNAME1
	INX
	STA	FILENAME,X
	CMP	#255
	BNE	GETNAME
	RTS		; exit loader
SETNAME1	STX	FILENAME	; length of file to load
	INY
	LDA	(MIKE1),Y
	STA	ENDPRG
	INY
	LDA	(MIKE1),Y
	STA	ENDPRG+1
	STY	FILELOOP+1
	JSR	FILELOAD	; now load it ok
	JMP	NEXTFILE

FILENAME	DB	2	; number of letters
	DS	12,0	; actual filename

FILESTL	DL	GAME_LEVEL
FILESTH	DH	GAME_LEVEL

GAME_LEVEL	DB	"LA",0
	DW	&7780	; all level data
CHAR_LEVEL	DB	"CA",0	; load charset in
	DW	&F800
MUSIC_NUM	DB	"M1",0	; music file number
	DB	255

FILELOAD	LDA	#0
	STA	DSTATUS
	LDX	COMMAND
	LDA	#$60
	STA	COMMAND	
	JSR	SENDSA
	LDA	#8	
	JSR	SENDTALK	
	LDA	COMMAND
	JSR	SENDTALKSA
	JSR	RECEIVESERIAL
	LDA	DSTATUS
	LSR	A
	LSR	A
	BCS	RETURN	; error
	JSR	RECEIVESERIAL
L13	LDA	#$FD
	AND	DSTATUS
	STA	DSTATUS
	JSR	RECEIVESERIAL
	TAX
	LDA	DSTATUS
	LSR	A
	LSR	A
	BCS	L13	
	TXA
	LDY	#0
	LDX	#$30	;RAM
	STX	1
	STA	(ENDPRG),Y
	LDX	#$0D	;IO
	STX	1
SK21	INC	ENDPRG	
	BNE	SK23		
	INC	ENDPRG+1
SK23	LDA	$D020
	EOR	#6
	STA	$D020
	BIT	DSTATUS
	BVC	L13
	JSR	SENDUNTALK	
	LDA	#8	; LIGHT OFF!
	JSR	SENDT+1
	LDA	COMMAND
	AND	#$EF
	ORA	#$E0
	JSR	SENDLISTENSA
	JSR	SENDUNTALK
RETURN	LDA	DSTATUS
	RTS

STATOR	ORA	DSTATUS
	STA	DSTATUS
	RTS

SENDSA	LDA	COMMAND
	BMI	RETURN	
	LDY	#1
	LDA	#0
	STA	DSTATUS
	LDA	#8
	JSR	SENDT+1
	LDA	COMMAND
	ORA	#$F0
	JSR	SENDLISTENSA
	LDA	DSTATUS	
	BPL	SK10	
	PLA
	PLA		; return address
	JMP	RETURN	; should be error message	
SK10	LDY	#0
GH	LDA	FILENAME+1,Y
	JSR	SENDSERDEF
	INY
	CPY	FILENAME
	BCC	GH
SK11	JSR	SENDUNLISTEN-5
	CLC
	RTS

SENDTALK	ORA	#$40
SENDT	BIT	$2009
SENDLISTEN	PHA
	BIT	C3PO
	BPL	SK1
	SEC
	ROR	TEMP1D
	JSR	SENDSERIAL
	LSR	C3PO
	LSR	TEMP1D
SK1	PLA
	STA	BUFFSB
	JSR	SERIAL1
	CMP	#$3F
	BNE	SK2
	JSR	CLOCKON
SK2	LDA	$DD00
	ORA	#8
	STA	$DD00
SE1	JSR	CLOCKOFF
	JSR	SERIAL1
	JSR	DELONEMS
SENDSERIAL	JSR	SERIAL1
	JSR	GETSIN
	BCS	TOUT1
	JSR	CLOCKON
	BIT	TEMP1D
	BPL	SK3
L01	JSR	GETSIN	
	BCC	L01	
L02	JSR	GETSIN
	BCS	L02
SK3	JSR	GETSIN
	BCC	SK3
	JSR	CLOCKOFF
	LDA	#8
	STA	COUNTDOWN
L03	LDA	$DD00
	CMP	$DD00
	BNE	L03
	ASL	A
	BCC	KB1+1
	ROR	BUFFSB
	BCS	SK4
	JSR	SERIAL0
	BNE	SK5
SK4	JSR	SERIAL1
SK5	JSR	CLOCKON
	NOP
	NOP
	NOP
	NOP
	LDA	$DD00
	AND	#$DF
	ORA	#$10
	STA	$DD00
	DEC	COUNTDOWN
	BNE	L03
	LDA	#4
	STA	$DC07
	LDA	#$19
	STA	$DC0F
	LDA	$DC0D
L04	LDA	$DC0D
	AND	#2
	BNE	KB1+1
	JSR	GETSIN
	BCS	L04
	RTS	

TOUT1	LDA	#$80
KB1	BIT	$3A9
SERTIMEOUT	JSR	STATOR
	CLC
	BCC	SENDUNLISTEN
SENDLISTENSA	STA	BUFFSB
	JSR	SE1	; see send listen
	
CLEARATN	LDA	$DD00
	AND	#$F7
	STA	$DD00	
	RTS

SENDTALKSA	STA	BUFFSB
	JSR	SE1
WAITCLOCK	JSR	SERIAL0
	JSR	CLEARATN
	JSR	CLOCKON
WC1	JSR	GETSIN
	BMI	WC1
	RTS

SENDSERDEF	BIT	C3PO
	BMI	SDF1
	SEC
	ROR	C3PO
	BNE	SDF2
SDF1	PHA
	JSR	SENDSERIAL				
	PLA
SDF2	STA	BUFFSB
	CLC
	RTS

SENDUNTALK	JSR	CLOCKOFF
	LDA	$DD00
	ORA	#8
	STA	$DD00
	LDA	#$5F
KB2	BIT	$3FA9
	JSR	SENDLISTEN
SENDUNLISTEN	JSR	CLEARATN
	TXA
	LDX	#$0A
L05	DEX
	BNE	L05
	TAX
	JSR	CLOCKON
	JMP	SERIAL1

RECEIVESERIAL	LDA	#0
	STA	COUNTDOWN
	JSR	CLOCKON
L06	JSR	GETSIN
	BPL	L06
L08	LDA	#01
	STA	$DC07
	LDA	#$19                	
	STA	$DC0F
	JSR	SERIAL1
	LDA	$DC0D
L07	LDA	$DC0D	
	AND	#2
	BNE	SK6
	JSR	GETSIN
	BMI	L07	
	BPL	SK7
SK6	LDA	COUNTDOWN	
	BEQ	SK8
	LDA	#2
	JMP	SERTIMEOUT	

SK8	JSR	SERIAL0
	JSR	CLOCKON
	LDA	#$40
	JSR	STATOR
	INC	COUNTDOWN
	BNE	L08
SK7	LDA	#8
	STA	COUNTDOWN
L09	LDA	$DD00
	CMP	$DD00
	BNE	L09
	ASL	A
	BPL	L09
	ROR	TEMP2
L10	LDA	$DD00
	CMP	$DD00
	BNE	L10
	ASL	A
	BMI	L10
	DEC	COUNTDOWN
	BNE	L09
	JSR	SERIAL0
	BIT	DSTATUS
	BVC	SK9
	JSR	SENDUNLISTEN+3
SK9	LDA	TEMP2
	CLC
	RTS

GETSIN	LDA	$DD00
	CMP	$DD00
	BNE	GETSIN
	ASL	A
	RTS

CLOCKON	LDA	$DD00
	AND	#$EF
	STA	$DD00
	RTS

CLOCKOFF	LDA	$DD00
	ORA	#$10
	STA	$DD00
	RTS

DELONEMS	TXA		; save old command
	LDX	#$B8
DEL1MS	DEX
	BNE	DEL1MS
	TAX
	RTS

SERIAL1	LDA	$DD00
	AND	#$DF	; '1' to serial
	STA	$DD00
	RTS

SERIAL0	LDA	$DD00
	ORA	#$20
	STA	$DD00
	RTS

	END


****************************************
*	UNPACK COMPRESSED DATA
****************************************

;UnPack
	;ORG	&6E80
PA_START

	;ORG	&9100	; save data to
PA_SAVE	;INCBIN	D:\C64\LEVEL1.DAT


	;ORG	&C000

MEMORY	EQU	&FC
STORE	EQU	&FE

	; Unpack Compressed Data
UNPACK	LDA	#<PA_START
	STA	MEMORY+1	; high
	LDA	#>PA_START
	STA	MEMORY+0	; low
	LDA	#<PA_SAVE
	STA	STORE+1	; high
	LDA	#>PA_SAVE
	STA	STORE+0	; low
	LDY	#0
UN_CRUNCH	LDA	(STORE),Y	; first byte
	BNE	ALL_GO	; 0 end of data
	RTS		; exit

ALL_GO	BMI	SPECIAL
	TAX		; amount of none repeat bytes
	JSR	BUMP_STORE	; advance on store
UN_LOOP	LDA	(STORE),Y
	STA	(MEMORY),Y
	JSR	BUMP_STORE	; advance pack memory
	JSR	BUMP_MEMORY	; advance store
	DEX
	BPL	UN_LOOP	; all of it
	JMP	UN_CRUNCH	; all data	

SPECIAL	AND	#%01111111	; get amount of duplicates
	TAX		; amount
	JSR	BUMP_STORE	; advance on store
	LDA	(STORE),Y	; get byte that is repeated
	STA	STORES+1	; live!
	JSR	BUMP_STORE	; past last byte
STORES	LDA	#255	; this byte
	STA	(MEMORY),Y	; save out
	JSR	BUMP_MEMORY	; advance
	DEX
	BNE	STORES	; all repeats
	JMP	UN_CRUNCH	; all data

	; Advance one on Pack store
BUMP_STORE	INC	STORE	; low + 1
	BNE	!NO_CARRY	; overflow 
	INC	STORE+1	; high + 1
!NO_CARRY	RTS

	; Advance one on Memory store
BUMP_MEMORY
	INC	MEMORY	; low + 1
	BNE	!NO_CARRY	; overflow 
	INC	MEMORY+1	; high + 1
!NO_CARRY	RTS
